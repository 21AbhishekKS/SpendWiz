package com.spendwiz.app.ViewModels

import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Build
import android.provider.Telephony
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.compose.ui.graphics.Color
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.map
import androidx.lifecycle.viewModelScope
import com.aay.compose.donutChart.model.PieChartData
import com.spendwiz.app.Database.money.CategoryExpense
import com.spendwiz.app.MainApplication
import com.spendwiz.app.Database.money.Money
import com.spendwiz.app.Database.money.MoneyDao
import com.spendwiz.app.Database.money.SubCategoryExpense
import com.spendwiz.app.Database.money.TransactionType
import com.spendwiz.app.MainActivity
import com.spendwiz.app.Notifications.NotificationHelper
import com.spendwiz.app.R
import com.spendwiz.app.SMSTransactionTracker.SmsTransactionParser
import com.spendwiz.app.Screens.DayStatus
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.text.SimpleDateFormat
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.util.*

class AddScreenViewModel : ViewModel() {

    val moneyDao = MainApplication.moneyDatabase.getMoneyDao()

    @RequiresApi(Build.VERSION_CODES.O)
    private val today = LocalDate.now()

    @RequiresApi(Build.VERSION_CODES.O)
    private val customFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy")

    @RequiresApi(Build.VERSION_CODES.O)
    private val formattedDateCustom = today.format(customFormatter)

    @RequiresApi(Build.VERSION_CODES.O)
    val todayMoneyList: LiveData<List<Money>> = moneyDao.getTodayTransactionByDate(formattedDateCustom)

    @RequiresApi(Build.VERSION_CODES.O)
    val currentMonthSummary: LiveData<MoneyDao.MonthlySummary?> =
        moneyDao.getMonthlyIncomeExpense(LocalDate.now().year.toString()).map { yearlySummaries ->
            val currentMonthNumber = LocalDate.now().month.value
            yearlySummaries.find { summary -> summary.month.toIntOrNull() == currentMonthNumber }
        }

    
    fun updateMoney(
        id: Int,
        amount: Double,
        description: String,
        type: TransactionType,
        category: String,
        time: String,
        subCategory: String,
        date: String
    ) = viewModelScope.launch(Dispatchers.IO) {
        val existing = moneyDao.getMoneyById(id) ?: return@launch

        val updated = existing.copy(
            amount = amount,
            description = description,
            type = type,
            category = category,
            subCategory = subCategory,
            date = date,
            time = time
        )
        moneyDao.updateMoney(updated)
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun addMoneyAndNotify(
        context: Context,
        amount: Double,
        description: String,
        type: TransactionType,
        date: String,
        category: String = "Others",
        subCategory: String? = null
    ) {
        viewModelScope.launch(Dispatchers.IO) {
            val money = Money(
                amount = amount,
                description = description,
                type = type,
                date = date,
                category = category,
                subCategory = subCategory
            )

            // 1. Insert and get autogenerated ID
            val rowId = moneyDao.addMoney(money)

            if (rowId != -1L) {
                val insertedMoney = money.copy(id = rowId.toInt())

                // 2. Show categorization notification
                NotificationHelper.showTransactionNotification(context, insertedMoney)

                Log.d("AddScreenViewModel", "‚úÖ Inserted & Notified: $insertedMoney")
            } else {
                Log.w("AddScreenViewModel", "‚ö†Ô∏è Duplicate transaction ignored")
            }
        }
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun addMoney1(
        id: Int = 0,
        amount: Double,
        description: String,
        type: TransactionType,
        date: String,
        time: String,
        category: String = "Others",
        subCategory: String? = null
    ) {
        viewModelScope.launch(Dispatchers.IO) {
            val money = Money(
                id = id,
                amount = amount,
                description = description,
                type = type,
                date = date,
                time = time,
                category = category,
                subCategory = subCategory
            )
            moneyDao.addMoney(money)
        }
    }

    @RequiresApi(Build.VERSION_CODES.O)
    suspend fun insertTransactionsFromSms(context: Context): Int {
        if (ActivityCompat.checkSelfPermission(context, android.Manifest.permission.READ_SMS)
            != PackageManager.PERMISSION_GRANTED
        ) return 0

        var insertedCount = 0
        val cursor = context.contentResolver.query(
            Uri.parse("content://sms/inbox"), null, null, null, "date DESC"
        )

        cursor?.use {
            val bodyIdx = it.getColumnIndex(Telephony.Sms.BODY)
            val dateIdx = it.getColumnIndex(Telephony.Sms.DATE)

            while (it.moveToNext()) {
                val body = it.getString(bodyIdx)
                val ts = it.getLong(dateIdx)
                val parsed = SmsTransactionParser.parse(body, ts) ?: continue

                // use fallback for duplicate check
                val upiRefForCheck = parsed.money.upiRefNo ?: "AUTO_${ts}_${parsed.money.amount.toInt()}"
                if (moneyDao.existsByUpiRefNo(upiRefForCheck) > 0) continue

                moneyDao.addMoney(parsed.money)
                insertedCount++
            }
        }
        return insertedCount
    }


    @RequiresApi(Build.VERSION_CODES.O)
    fun runSmsImportOnce(context: Context) {
        val prefs = context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
        val hasRunBefore = prefs.getBoolean("sms_import_done", false)

        if (!hasRunBefore) {
            viewModelScope.launch(Dispatchers.IO) {
                val insertedCount = insertTransactionsFromSms(context)

                if (insertedCount > 0) {
                    prefs.edit().putBoolean("sms_import_done", true).apply()
                    Log.i("SMS_IMPORT", "üèÅ Initial SMS import complete, inserted=$insertedCount")
                } else {
                    Log.w("SMS_IMPORT", "‚ö†Ô∏è No SMS imported, will retry on next launch")
                }
            }
        } else {
            Log.i("SMS_IMPORT", "‚ÑπÔ∏è SMS import already done once, skipping")
        }
    }

    fun getCategoryExpensesForMonth(month: String, year: String): LiveData<List<PieChartData>> {
        return moneyDao.getCategoryExpensesByMonthAndYear(month, year).map { categoryList ->
            mapCategoryExpensesToPieChartData(categoryList)
        }
    }

    private fun mapCategoryExpensesToPieChartData(expenses: List<CategoryExpense>): List<PieChartData> {
        val colors = listOf(
            Color(0xFF8B0000), // Very Dark Red (Maroon)
            Color(0xFFC62828), // Dark Red
            Color(0xFF6A1B1A), // Red-Brown
            Color(0xFFFFCDD2), // Light Red
            Color(0xFF4E342E), // Coffee Brown
            Color(0xFFEF9A9A), // Soft Red
            Color(0xFF3E2723), // Dark Coffee
            Color(0xFFE57373), // Medium Red
            Color(0xFF5D4037),  // Rich Brown
            Color(0xFFB71C1C)  // Deep Red
        )

        return expenses.mapIndexed { index, item ->
            PieChartData(
                partName = item.category+": "+item.total,
                data = item.total,
                color = colors[index % colors.size]
            )
        }
    }

    fun getSubCategoryExpensesForMonth(
        category: String,
        month: String,
        year: String
    ): LiveData<List<PieChartData>> {
        return moneyDao.getSubCategoryExpensesByMonthAndYear(category, month, year)
            .map { subCategoryList ->
                mapSubCategoryExpensesToPieChartData(subCategoryList)
            }
    }

    private fun mapSubCategoryExpensesToPieChartData(expenses: List<SubCategoryExpense>): List<PieChartData> {
        val colors = listOf(
            Color(0xFF1976D2),
            Color(0xFF0288D1),
            Color(0xFF26C6DA),
            Color(0xFF4DD0E1),
            Color(0xFF80DEEA),
            Color(0xFFB2EBF2),
            Color(0xFFE0F7FA)
        )

        return expenses.mapIndexed { index, item ->
            PieChartData(
                partName = (item.subCategory ?: "Others") + ": " + item.total,
                data = item.total,
                color = colors[index % colors.size]
            )
        }
    }


    fun deleteMoney(id: Int) {
        Log.v( "delete", "delete method called")

        viewModelScope.launch(Dispatchers.IO) {
            val money = moneyDao.getMoneyById(id)
            if (money != null) {
                moneyDao.deleteMoney(money)
            }
        }
    }

    // for list of money items from insight screen
    fun updateTransactionType(ids: List<Int>, newType: TransactionType) =
        viewModelScope.launch { moneyDao.updateTransactionType(ids, newType) }

    fun updateCategory(ids: List<Int>, newCategory: String) =
        viewModelScope.launch { moneyDao.updateCategory(ids, newCategory) }

    fun updateSubCategory(ids: List<Int>, newSubCategory: String) =
        viewModelScope.launch { moneyDao.updateSubCategory(ids, newSubCategory) }

    fun deleteTransactions(ids: List<Int>) =
        viewModelScope.launch { moneyDao.deleteTransactions(ids) }

    private fun showTransactionNotification(context: Context, money: Money) {
        val notificationIntent = Intent(context, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            context, 0, notificationIntent, PendingIntent.FLAG_IMMUTABLE
        )

        val notification = NotificationCompat.Builder(context, "transaction_channel")
            .setSmallIcon(R.drawable.notification_icon)
            .setContentTitle("New ${money.type.name.lowercase().replaceFirstChar { it.uppercase() }} added")
            .setContentText("${money.bankName}: ‚Çπ${money.amount} on ${money.date}")
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)
            .build()

        val manager = NotificationManagerCompat.from(context)
        if (ActivityCompat.checkSelfPermission(
                context, android.Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED
        ) {
            manager.notify(System.currentTimeMillis().toInt(), notification)
        }
    }

    //For yearly overview
    fun getYearlyData(year: String): LiveData<List<MoneyDao.MonthlySummary>> {
        return moneyDao.getMonthlyIncomeExpense(year)
    }

    // inside AddScreenViewModel (add imports: kotlinx.coroutines.Dispatchers, kotlinx.coroutines.withContext, androidx.lifecycle.MutableLiveData)
    private val _dayStatusesLoading = MutableLiveData(false)
    val dayStatusesLoading: LiveData<Boolean> = _dayStatusesLoading

    @RequiresApi(Build.VERSION_CODES.O)
    fun getDayStatusesForYear(year: Int): LiveData<Map<LocalDate, DayStatus>> {
        val result = MutableLiveData<Map<LocalDate, DayStatus>>()

        viewModelScope.launch {
            _dayStatusesLoading.postValue(true)

            // Do heavy work on Default (CPU-bound)
            val map = withContext(Dispatchers.Default) {
                val start = LocalDate.of(year, 1, 1)
                val end = LocalDate.of(year, 12, 31)
                val yearPrefix = "%/$year" // matches your DAO query

                // Query DB on IO
                val rawList = withContext(Dispatchers.IO) {
                    moneyDao.getTransactionsForYear(yearPrefix)
                }

                // group by date string -> parse once.
                val transactionsByDate = rawList.groupBy { item ->
                    // parse date string "dd/MM/yyyy" safely
                    val parts = item.date.split("/")
                    val d = parts.getOrNull(0)?.toIntOrNull() ?: 1
                    val m = parts.getOrNull(1)?.toIntOrNull() ?: 1
                    val y = parts.getOrNull(2)?.toIntOrNull() ?: year
                    LocalDate.of(y, m, d)
                }

                // Pre-size map for all days
                val totalDays = java.time.temporal.ChronoUnit.DAYS.between(start, end).toInt() + 1
                val m = LinkedHashMap<LocalDate, DayStatus>(totalDays)

                var current = start
                while (!current.isAfter(end)) {
                    val txs = transactionsByDate[current]

                    val status = when {
                        txs == null || txs.isEmpty() -> DayStatus.NoTransaction
                        txs.all {
                            (it.category != null && !it.category.equals("Others", true))
                                    && (it.subCategory != null && !it.subCategory.equals("Others", true))
                        } -> DayStatus.Categorized
                        else -> DayStatus.NotCategorized
                    }

                    m[current] = status
                    current = current.plusDays(1)
                }
                m
            }

            result.value = map
            _dayStatusesLoading.postValue(false)
        }

        return result
    }

    // For yearly income and expense screen form Annual screen
    fun getYearlyCategoryData(year: String, type: TransactionType): LiveData<List<CategoryData>> {
        val result = MutableLiveData<List<CategoryData>>()

        viewModelScope.launch(Dispatchers.IO) {
            val yearPrefix = "%/$year" // matches dd/MM/yyyy format
            val transactions = moneyDao.getTransactionsForYear(yearPrefix)

            val filtered = transactions.filter { money ->
                // check type
                val full = moneyDao.getMoneyById(money.id)
                full?.type == type
            }

            val grouped = filtered.groupBy { it.category ?: "Others" }.map { (category, list) ->
                val subGrouped = list.groupBy { it.subCategory ?: "Others" }.map { (sub, subList) ->
                    SubCategoryData(
                        name = sub,
                        amount = subList.sumOf { full ->
                            moneyDao.getMoneyById(full.id)?.amount ?: 0.0
                        }
                    )
                }

                CategoryData(
                    name = category,
                    total = subGrouped.sumOf { it.amount },
                    subCategories = subGrouped
                )
            }

            result.postValue(grouped)
        }

        return result
    }

    // Fetch uncategorized transactions by name for Bulk update feature
    fun getUncategorizedByNameOnce(name: String, onResult: (List<Money>) -> Unit) {
        viewModelScope.launch(Dispatchers.IO) {
            val list = moneyDao.getUncategorizedByNameOnce(name)
            withContext(Dispatchers.Main) {
                onResult(list)
            }
        }
    }

    fun getUncategorizedByNameOnceExceptCurrent(
        name: String,
        excludeId: Int,
        onResult: (List<Money>) -> Unit
    ) {
        viewModelScope.launch(Dispatchers.IO) {
            val list = moneyDao.getUncategorizedByNameOnceExceptCurrent(name, excludeId)
            withContext(Dispatchers.Main) {
                onResult(list)
            }
        }
    }

    // Bulk update selected transactions
    fun bulkUpdateCategory(ids: List<Int>, newCategory: String, newSubCategory: String?) {
        viewModelScope.launch(Dispatchers.IO) {
            moneyDao.bulkUpdateCategory(ids, newCategory, newSubCategory)
        }
    }

}
// Inside AddScreenViewModel.kt
data class SubCategoryData(
    val name: String,
    val amount: Double
)

data class CategoryData(
    val name: String,
    val total: Double,
    val subCategories: List<SubCategoryData>
)